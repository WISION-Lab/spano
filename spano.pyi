from typing import List, Tuple, Optional
from typing_extensions import Self

import numpy as np

class Mapping:
    mat: np.ndarray
    kind: str

    @classmethod
    def from_matrix(cls, mat: np.ndarray, kind: str) -> Self: ...

    # Some of these are actually staticmethods that return a class
    # instance, this avoids having to have a separate pyo3 wrapper
    @classmethod
    def from_params(cls, params: List[float]) -> Self: ...
    @classmethod
    def scale(cls, x: float, y: float) -> Self: ...
    @classmethod
    def shift(cls, x: float, y: float) -> Self: ...
    @classmethod
    def identity(cls) -> Self: ...
    @staticmethod
    def maximum_extent(
        maps: List[Self], sizes: List[Tuple[int, int]]
    ) -> Tuple[np.ndarray, Self]: ...
    @staticmethod
    def interpolate_scalar(ts: List[float], maps: List[Self], query: float) -> Self: ...
    @staticmethod
    def interpolate_array(
        ts: List[float], maps: List[Self], query: List[float]
    ) -> List[Self]: ...
    @staticmethod
    def accumulate(mappings: List[Self]) -> List[Self]: ...
    @staticmethod
    def with_respect_to(mappings: List[Self], wrt_map: Self) -> List[Self]: ...
    @staticmethod
    def with_respect_to_idx(mappings: List[Self], wrt_idx: float) -> List[Self]: ...
    @staticmethod
    def accumulate_wrt_idx(mappings: List[Self], wrt_idx: float) -> List[Self]: ...
    def get_params(self) -> List[float]: ...
    def get_params_full(self) -> List[float]: ...
    def inverse(self) -> Self: ...
    def transform(self, *, lhs: Optional[Self], rhs: Optional[Self]) -> Self: ...
    def rescale(self, scale: float) -> Self: ...
    def warp_points(self, points: np.ndarray) -> np.ndarray: ...
    def corners(self, size: Tuple[int, int]) -> np.ndarray: ...
    def extent(self, size: Tuple[int, int]) -> Tuple[np.ndarray, np.ndarray]: ...
    def warp_array(
        self,
        data: np.ndarray,
        out_size: Tuple[int, int],
        background: Optional[List[float]],
    ) -> Tuple[np.ndarray, np.ndarray]: ...
